(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * LPF
 * Low Pass Filter for JavaScript
 *
 * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>
 * @copyright MIT
 */
var LPF = function(smoothing) {
    this.smoothing = smoothing || 0.5; // must be smaller than 1
    this.buffer = []; // FIFO queue
    this.bufferMaxSize = 10;
};

LPF.prototype = {

    /**
     * Init buffer with array of values
     * 
     * @param {array} values
     * @returns {array}
     * @access public
     */
    init: function(values) {
        for (var i = 0; i < values.length; i++) {
            this.__push(values[i]);
        }
        return this.buffer;
    },

    /**
     * Add new value to buffer (FIFO queue)
     *
     * @param {integer|float} value
     * @returns {integer|float}
     * @access private
     */
    __push: function(value) {
        var removed = (this.buffer.length === this.bufferMaxSize)
            ? this.buffer.shift()
            : 0;

        this.buffer.push(value);
        return removed;
    },

    /**
     * Smooth value from stream
     *
     * @param {integer|float} nextValue
     * @returns {integer|float}
     * @access public
     */
    next: function (nextValue) {
        var self = this;
        // push new value to the end, and remove oldest one
        var removed = this.__push(nextValue);
        // smooth value using all values from buffer
        var result = this.buffer.reduce(function(last, current) {
            return self.smoothing * current + (1 - self.smoothing) * last;
        }, removed);
        // replace smoothed value
        this.buffer[this.buffer.length - 1] = result;
        return result;
    },

    /**
     * Smooth array of values
     *
     * @param {array} values
     * @returns {undefined}
     * @access public
     */
    smoothArray: function (values){
        var value = values[0];
        for (var i = 1; i < values.length; i++){
            var currentValue = values[i];
            value += (currentValue - value) * this.smoothing;
            values[i] = Math.round(value);
        }
        return values;
    }
};

module.exports = new LPF();

},{}],2:[function(require,module,exports){
module.exports = require('./LPF.js');

var lpf = require('lpf');
var timeOutVar = null;
var currentArrowAngle = -120; // 0 rpm
lpf.init([0]);
//lpf.smoothing = 0.01;
//lpf.next(4000);
//console.log(lpf.buffer);


function rpmToAngle(rpm) { //convert rpm to degrees
    var divided = rpm / 1000;
    var angle = (divided*30) - 120;
    return angle;
}

function angleToRpm(angle) { // convert degrees to rpm
    var divided = (angle+120) / 30;
    var rpm = divided*1000;
    return rpm;
}

function moveArrow(targetDeg, lastArrowAngle, tempTargetRpm) { 
    if (currentArrowAngle == targetDeg) {
        //console.log("smoothing is:"+ smoothing);
        //console.log(values);  // see intermediate values
        clearTimeout(timeOutVar);
        return;
    } 
    if (currentArrowAngle == lastArrowAngle) {
        lpf.smoothing+=0.01;
    }
    var targetRpm = angleToRpm(targetDeg);
    if (currentArrowAngle < targetDeg && lpf.buffer.length > 1) {
        tempTargetRpm = lpf.next(targetRpm);
        while (tempTargetRpm <= lpf.buffer[lpf.buffer.length-2]) {
            lpf.buffer.pop();
            lpf.smoothing+=0.01;
            tempTargetRpm = lpf.next(targetRpm);
        }
    }   
    else if (currentArrowAngle > targetDeg && lpf.buffer.length > 1) {
        tempTargetRpm = lpf.next(targetRpm);
        while (tempTargetRpm >= lpf.buffer[lpf.buffer.length-2]) {
            lpf.buffer.pop();
            lpf.smoothing+=0.01;
            tempTargetRpm = lpf.next(targetRpm);
        }
    }
    else {
        tempTargetRpm = lpf.next(targetRpm);
    }
    currentArrowAngle = rpmToAngle(tempTargetRpm);
    lastArrowAngle = currentArrowAngle;
    $('#line').css('transform',"rotate(" + currentArrowAngle + "deg)")
    timeOutVar = setTimeout( function(){moveArrow(targetDeg, lastArrowAngle, tempTargetRpm);}, 25 );
}


$('#myButton').on('click', function () {

    var rpm = $('#target').val();

    var angle = rpmToAngle(rpm) ;
    //console.log(" " + angle);
    var newRpm = angleToRpm(angle);
    console.log("Next target: " + newRpm);

    lpf.smoothing = 0.01;
    var tempTargetRpm;
    var lastArrowAngle;
    //console.log(values);
    moveArrow(angle, lastArrowAngle, tempTargetRpm);   
    
});



},{"./LPF.js":1,"lpf":2}]},{},[2]);
